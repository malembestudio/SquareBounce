<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>SQUARE BOUNCE</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    :root {
      /* Mant√©n estos tama√±os en sync con el JS (JOY_SIZE y STICK_SIZE) */
      --joy-size: 140px;
      --stick-size: 68px;
    }
    body { margin: 0; background: #000; overflow: hidden; }
    canvas { display: block; margin: auto; background: #111; touch-action: none; }

    /* Bot√≥n de iniciar/reiniciar */
    #btnStart {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%,-50%);
      background: rgba(0,0,0,0.4);
      border: 2px solid white;
      border-radius: 14px;
      padding: 14px 26px;
      color: white;
      font-size: 18px;
      z-index: 20;
      display: none;
      cursor: pointer;
      backdrop-filter: blur(2px);
    }

    /* Mensaje de rotar dispositivo */
    #rotateMsg {
      position: fixed;
      inset: 0;
      background: #000;
      color: white;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      text-align: center;
      z-index: 30;
    }

    /* Joystick t√°ctil (derecha) */
    #joystick {
      position: fixed;
      bottom: 28px;
      right: 28px;              /* üëâ joystick a la derecha */
      width: var(--joy-size);
      height: var(--joy-size);
      background: rgba(255,255,255,0.08);
      border-radius: 50%;
      touch-action: none;
      z-index: 10;
      display: none;            /* solo visible cuando se juega */
      backdrop-filter: blur(2px);
      border: 1px solid rgba(255,255,255,0.15);
    }
    #stick {
      width: var(--stick-size);
      height: var(--stick-size);
      background: rgba(255,255,255,0.35);
      border-radius: 50%;
      position: absolute;
      transition: left 0.05s, top 0.05s;
      will-change: left, top;
      border: 1px solid rgba(255,255,255,0.4);
      /* left/top se establecen desde JS para centrar correctamente */
    }
  </style>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#000000">
</head>
<body>
  <canvas id="juego"></canvas>

  <!-- Bot√≥n t√°ctil de inicio/reinicio -->
  <button id="btnStart">TOCAR PARA EMPEZAR</button>

  <!-- Mensaje de rotar dispositivo -->
  <div id="rotateMsg">Por favor gira tu dispositivo<br>‚ÜîÔ∏è Horizontal (Landscape)</div>

  <!-- Joystick -->
  <div id="joystick" aria-label="Joystick t√°ctil">
    <div id="stick"></div>
  </div>

  <script>
    // ======== Referencias DOM ========
    const canvas = document.getElementById("juego");
    const ctx = canvas.getContext("2d");
    const btnStart = document.getElementById("btnStart");
    const rotateMsg = document.getElementById("rotateMsg");
    const joystick = document.getElementById("joystick");
    const stick = document.getElementById("stick");

    // ======== Estado y constantes ========
    let estado = "inicio"; // "inicio" | "jugando" | "gameover"

    const ENEMIGO_TAM_INICIAL = 40;  // lado del enemigo
    const CRECIMIENTO_PX = 2;        // +2 px por rebote
    const REDUCCION_PX = 2;          // -2 px por moneda roja
    const JUGADOR_TAM = 40;
    const MONEDA_RADIO = 10;
    const RAYO_RADIO = 12;
    const FRESA_RADIO = 14;
    const VEL_BASE = 4;
    const BOOST_FACTOR = 2;
    const BOOST_MS = 8000;
    const FRESA_MS = 10000;          // fresa dura 10s

    // Tama√±os joystick (deben coincidir con CSS)
    const JOY_SIZE = 140;
    const STICK_SIZE = 68;

    // Jugador
    let x, y, color = "red";
    let keys = {};
    let boostHasta = 0;

    // Enemigo
    let ex, ey, etam, evx, evy;

    // Monedas
    let mx, my;   // amarilla
    let mrx, mry; // roja

    // Rayo
    let rayoActivo = false;
    let rx = 0, ry = 0;
    let siguienteRayo = 50; // por stage

    // Fresa
    let fresaActiva = false;
    let fx = 0, fy = 0;
    let siguienteFresa = 100; // por stage
    let fresaExpira = 0;

    // Puntos y Stage
    let puntosStage = 0; // se reinicia por stage
    let stage = 1;
    let mostrarStageCartel = false;
    let stageCartelHasta = 0;

    // Textos flotantes
    let textos = []; // {msg, x, y, alpha}

    // ======== Audio ========
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let musicaActiva = false;
    let intervaloMusica = null;
    let audioDesbloqueado = false;

    function desbloquearAudio() {
      if (!audioDesbloqueado) {
        audioCtx.resume?.();
        audioDesbloqueado = true;
      }
    }
    function beep(freq, dur, type = "square", vol = 0.2) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      gain.gain.setValueAtTime(vol, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.start(); osc.stop(audioCtx.currentTime + dur);
    }
    function sonidoRebote(){ beep(200,0.08,"square",0.15); }
    function sonidoMoneda(){ beep(650,0.12,"sine",0.22); }
    function sonidoMonedaRoja(){ beep(160,0.16,"sawtooth",0.25); }
    function sonidoRayo(){ beep(400,0.09,"square",0.3); setTimeout(()=>beep(800,0.09,"square",0.28),90); }
    function sonidoFresa(){ beep(700,0.09,"triangle",0.28); setTimeout(()=>beep(500,0.12,"triangle",0.24),100); }
    function sonidoGameOver(){
      beep(600,0.18,"triangle",0.3);
      setTimeout(()=>beep(400,0.18,"triangle",0.25),180);
      setTimeout(()=>beep(220,0.25,"triangle",0.22),360);
    }
    function reproducirMusica(){
      if (musicaActiva) return;
      musicaActiva = true;
      const notas=[440,523,392,659];
      let i=0;
      intervaloMusica=setInterval(()=>{ beep(notas[i%notas.length],0.2,"square",0.13); i++; },400);
    }
    function detenerMusica(){
      musicaActiva=false;
      if (intervaloMusica) clearInterval(intervaloMusica);
      intervaloMusica=null;
    }

    // ======== Utilidades ========
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    function colisionAABB_centro(ax, ay, aw, ah, bx, by, bw, bh) {
      // ‚úÖ corregido: √∫ltima comparaci√≥n usa 'by'
      return (
        ax - aw/2 < bx + bw/2 &&
        ax + aw/2 > bx - bw/2 &&
        ay - ah/2 < by + bh/2 &&
        ay + ah/2 > by - bh/2
      );
    }
    function colisionCirculoCirculo(ax, ay, ar, bx, by, br) {
      const dx = ax - bx, dy = ay - by;
      return (dx*dx + dy*dy) <= (ar + br) * (ar + br);
    }
    function factorVelocidadPorStage(n){
      const capped=Math.min(n,5);
      return 1 + 0.333*(capped-1);
    }

    // ======== Canvas + orientaci√≥n ========
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (typeof x === "number") {
        x = clamp(x, JUGADOR_TAM/2, canvas.width - JUGADOR_TAM/2);
        y = clamp(y, JUGADOR_TAM/2, canvas.height - JUGADOR_TAM/2);
      }
      if (typeof ex === "number" && typeof etam === "number") {
        ex = clamp(ex, etam/2, canvas.width - etam/2);
        ey = clamp(ey, etam/2, canvas.height - etam/2);
      }
    }

    function actualizarUIporEstado(){
      const isPortrait = window.innerHeight > window.innerWidth;
      if (isPortrait) return;

      if (estado === "inicio") {
        btnStart.style.display = "block";
        btnStart.innerText = "TOCAR PARA EMPEZAR";
        joystick.style.display = "none";
      } else if (estado === "jugando") {
        btnStart.style.display = "none";
        joystick.style.display = "block";
        centerStick(); // ahora el joystick s√≠ est√° visible
      } else if (estado === "gameover") {
        btnStart.style.display = "block";
        btnStart.innerText = "TOCAR PARA REINICIAR";
        joystick.style.display = "none";
      }
    }

    function checkOrientation() {
      const isPortrait = window.innerHeight > window.innerWidth;
      if (isPortrait) {
        rotateMsg.style.display = "flex";
        canvas.style.display = "none";
        btnStart.style.display = "none";
        joystick.style.display = "none";
      } else {
        rotateMsg.style.display = "none";
        canvas.style.display = "block";
        actualizarUIporEstado();
      }
    }

    window.addEventListener("resize", ()=>{ resizeCanvas(); checkOrientation(); });
    window.addEventListener("orientationchange", checkOrientation);
    document.addEventListener("fullscreenchange", resizeCanvas);

    // ======== Setup ========
    function colocarMonedas() {
      mx  = Math.random() * (canvas.width  - 2*MONEDA_RADIO) + MONEDA_RADIO;
      my  = Math.random() * (canvas.height - 2*MONEDA_RADIO) + MONEDA_RADIO;
      mrx = Math.random() * (canvas.width  - 2*MONEDA_RADIO) + MONEDA_RADIO;
      mry = Math.random() * (canvas.height - 2*MONEDA_RADIO) + MONEDA_RADIO;
    }

    function iniciarStage(n){
      // Jugador
      x = canvas.width/2;
      y = Math.random() < 0.5 ? 40 : canvas.height - 40;
      color = "red";
      boostHasta = 0;

      // Enemigo
      etam = ENEMIGO_TAM_INICIAL;
      const esquina = Math.floor(Math.random()*4);
      if (esquina===0){ ex=etam/2; ey=etam/2; evx=3; evy=2; }
      else if (esquina===1){ ex=canvas.width-etam/2; ey=etam/2; evx=-3; evy=2; }
      else if (esquina===2){ ex=etam/2; ey=canvas.height-etam/2; evx=3; evy=-2; }
      else { ex=canvas.width-etam/2; ey=canvas.height-etam/2; evx=-3; evy=-2; }
      const f=factorVelocidadPorStage(n);
      evx*=f; evy*=f;

      // Monedas / powerups
      colocarMonedas();
      rayoActivo=false;  siguienteRayo=50;
      fresaActiva=false; siguienteFresa=100; fresaExpira=0;

      // Puntos del stage
      puntosStage=0;

      // Cartel Stage
      mostrarStageCartel=true;
      stageCartelHasta=Date.now()+2000;

      // Limpia textos flotantes
      textos.length = 0;
    }

    function inicializarJuego(){
      // üîä Desbloqueo de audio y m√∫sica
      desbloquearAudio();
      reproducirMusica();

      // üî≤ Pantalla completa (en todo el documento para incluir joystick)
      const el = document.documentElement;
      try {
        const p = el.requestFullscreen?.() || el.webkitRequestFullscreen?.() || el.msRequestFullscreen?.();
        // Algunas implementaciones retornan promesa; capturamos errores silenciosamente
        if (p && typeof p.then === "function") {
          p.catch(()=>{ /* ignorar rechazo (p.ej., bloqueado por navegador) */ });
        }
      } catch(e){ /* ignorar */ }

      stage=1;
      iniciarStage(stage);
      estado="jugando";
      actualizarUIporEstado();
      resizeCanvas(); // por si el fullscreen cambi√≥ el viewport
    }

    // ======== Entrada teclado ========
    document.addEventListener("keydown",(e)=>{
      keys[e.key]=true;
      if (estado==="inicio" && e.code==="Space"){ inicializarJuego(); }
      else if (estado==="gameover" && (e.key==="r"||e.key==="R")){ inicializarJuego(); }
    });
    document.addEventListener("keyup",(e)=> keys[e.key]=false);

    // ======== Joystick (pointer + touch) ========
    let joyX = 0, joyY = 0;       // -1..1
    let joyActive = false;

    function centerStick(){
      // Centramos usando tama√±os conocidos aunque est√© oculto
      const offset = (JOY_SIZE - STICK_SIZE) / 2;
      stick.style.left = offset + "px";
      stick.style.top  = offset + "px";
    }

    function updateJoystickFromEvent(e){
      const rect = joystick.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top  + rect.height/2;

      let px, py;
      if (e.touches && e.touches[0]) { px = e.touches[0].clientX; py = e.touches[0].clientY; }
      else { px = e.clientX; py = e.clientY; }

      // vector desde el centro
      let dx = px - cx;
      let dy = py - cy;

      const maxR = rect.width/2;
      const dist = Math.hypot(dx, dy) || 1;

      // limitar al c√≠rculo del joystick
      if (dist > maxR) {
        const s = maxR / dist;
        dx *= s; dy *= s;
      }

      // normalizar a [-1..1]
      joyX = dx / maxR;
      joyY = dy / maxR;

      // mover stick con left/top
      const offset = (rect.width - STICK_SIZE) / 2;
      stick.style.left = (offset + joyX * offset) + "px";
      stick.style.top  = (offset + joyY * offset) + "px";

      e.preventDefault?.();
    }

    function resetJoystick(){
      joyX = 0; joyY = 0;
      centerStick();
    }

    // Pointer events
    joystick.addEventListener("pointerdown", (e)=>{ joyActive=true; updateJoystickFromEvent(e); });
    window.addEventListener("pointermove",  (e)=>{ if (joyActive) updateJoystickFromEvent(e); });
    window.addEventListener("pointerup",    ()=>{ joyActive=false; resetJoystick(); });

    // Fallback touch (por si el navegador no promueve a pointer)
    joystick.addEventListener("touchstart", (e)=>{ joyActive=true; updateJoystickFromEvent(e); }, {passive:false});
    joystick.addEventListener("touchmove",  (e)=>{ if (joyActive) updateJoystickFromEvent(e); }, {passive:false});
    joystick.addEventListener("touchend",   ()=>{ joyActive=false; resetJoystick(); }, {passive:false});

    // ======== Bot√≥n inicio/reinicio ========
    btnStart.addEventListener("click", inicializarJuego);

    // ======== L√≥gica del juego ========
    function moverJugador(){
      const ahora=Date.now();
      const velBase = VEL_BASE * (ahora < boostHasta ? BOOST_FACTOR : 1);

      // Direcci√≥n por teclado
      let kx = 0, ky = 0;
      if (keys["ArrowLeft"])  kx -= 1;
      if (keys["ArrowRight"]) kx += 1;
      if (keys["ArrowUp"])    ky -= 1;
      if (keys["ArrowDown"])  ky += 1;

      // Combinar con joystick (anal√≥gico) y normalizar
      let vx = kx + joyX;
      let vy = ky + joyY;

      const mag = Math.hypot(vx, vy);
      if (mag > 0) {
        vx /= mag;
        vy /= mag;

        x += vx * velBase;
        y += vy * velBase;

        // Color seg√∫n direcci√≥n dominante
        if (vy < -0.4)      color = "yellow";
        else if (vy > 0.4)  color = "blue";
        else if (vx < -0.4) color = "green";
        else if (vx > 0.4)  color = "purple";
      }

      x = clamp(x, JUGADOR_TAM/2, canvas.width - JUGADOR_TAM/2);
      y = clamp(y, JUGADOR_TAM/2, canvas.height - JUGADOR_TAM/2);
    }

    function moverEnemigo(){
      ex+=evx; ey+=evy;
      let rebotedX=false, rebotedY=false;

      // Borde X
      if (ex - etam/2 < 0){ ex=etam/2; evx*=-1; rebotedX=true; }
      else if (ex + etam/2 > canvas.width){ ex=canvas.width - etam/2; evx*=-1; rebotedX=true; }

      // Borde Y
      if (ey - etam/2 < 0){ ey=etam/2; evy*=-1; rebotedY=true; }
      else if (ey + etam/2 > canvas.height){ ey=canvas.height - etam/2; evy*=-1; rebotedY=true; }

      if (rebotedX){ puntosStage++; sonidoRebote(); }
      if (rebotedY){ puntosStage++; sonidoRebote(); }
      if (rebotedX || rebotedY){
        etam += CRECIMIENTO_PX;
        ex = clamp(ex, etam/2, canvas.width - etam/2);
        ey = clamp(ey, etam/2, canvas.height - etam/2);
      }

      // Rayo cada 50 pts del stage
      if (puntosStage >= siguienteRayo && !rayoActivo){
        rx = Math.random()*(canvas.width - 2*RAYO_RADIO) + RAYO_RADIO;
        ry = Math.random()*(canvas.height - 2*RAYO_RADIO) + RAYO_RADIO;
        rayoActivo = true;
        siguienteRayo += 50;
      }

      // Fresa cada 100 pts del stage
      if (puntosStage >= siguienteFresa && !fresaActiva){
        fx = Math.random()*(canvas.width - 2*FRESA_RADIO) + FRESA_RADIO;
        fy = Math.random()*(canvas.height - 2*FRESA_RADIO) + FRESA_RADIO;
        fresaActiva = true;
        fresaExpira = Date.now() + FRESA_MS;
        siguienteFresa += 100;
      }
    }

    function actualizar(){
      if (estado!=="jugando") return;

      moverJugador();
      moverEnemigo();

      // Choque con enemigo
      if (colisionAABB_centro(x,y,JUGADOR_TAM,JUGADOR_TAM, ex,ey,etam,etam)){
        estado="gameover";
        detenerMusica();
        sonidoGameOver();
        actualizarUIporEstado();
        return;
      }

      // Moneda amarilla: +5 pts stage + texto flotante
      if (colisionCirculoCirculo(x,y,JUGADOR_TAM/2, mx,my,MONEDA_RADIO)){
        puntosStage += 5;
        textos.push({ msg:"+5p", x:x, y:y - JUGADOR_TAM/2 - 8, alpha:1 });
        colocarMonedas();
        sonidoMoneda();
      }

      // Moneda roja: -2 px (m√≠nimo tama√±o inicial)
      if (colisionCirculoCirculo(x,y,JUGADOR_TAM/2, mrx,mry,MONEDA_RADIO)){
        etam = Math.max(ENEMIGO_TAM_INICIAL, etam - REDUCCION_PX);
        ex = clamp(ex, etam/2, canvas.width - etam/2);
        ey = clamp(ey, etam/2, canvas.height - etam/2);
        colocarMonedas();
        sonidoMonedaRoja();
      }

      // Rayo: boost 8s
      if (rayoActivo && colisionCirculoCirculo(x,y,JUGADOR_TAM/2, rx,ry,RAYO_RADIO)){
        rayoActivo=false;
        boostHasta = Date.now() + BOOST_MS;
        sonidoRayo();
      }

      // Fresa: vuelve al tama√±o inicial (instant√°neo) +10p + texto flotante, o expira
      if (fresaActiva){
        if (colisionCirculoCirculo(x,y,JUGADOR_TAM/2, fx,fy,FRESA_RADIO)){
          fresaActiva=false;
          etam = ENEMIGO_TAM_INICIAL;   // reducci√≥n instant√°nea
          ex = clamp(ex, etam/2, canvas.width - etam/2);
          ey = clamp(ey, etam/2, canvas.height - etam/2);
          puntosStage += 10;
          textos.push({ msg:"+10p", x:x, y:y - JUGADOR_TAM/2 - 8, alpha:1 });
          sonidoFresa();
        } else if (Date.now() > fresaExpira){
          fresaActiva=false;
        }
      }

      // Textos flotantes
      for (let i = textos.length - 1; i >= 0; i--) {
        const t = textos[i];
        t.y -= 0.6;
        t.alpha -= 0.02;
        if (t.alpha <= 0) textos.splice(i, 1);
      }

      // Cambio de stage cada 300 pts del stage
      if (puntosStage >= 300){
        stage++;
        iniciarStage(stage);
      }
    }

    // ======== Render ========
    function dibujar(){
      ctx.clearRect(0,0,canvas.width,canvas.height);

      if (estado === "inicio"){
        ctx.fillStyle="white";
        ctx.font="40px Arial";
        ctx.textAlign="center"; ctx.textBaseline="alphabetic";
        ctx.fillText("SQUARE BOUNCE", canvas.width/2, canvas.height/2 - 40);

        ctx.fillStyle="yellow"; ctx.font="20px Arial";
        ctx.fillText("Joystick t√°ctil o flechas del teclado", canvas.width/2, canvas.height/2 + 10);
        ctx.fillText("Esquiva al enemigo y recoge powerups", canvas.width/2, canvas.height/2 + 40);

        if (Math.floor(Date.now()/500)%2===0){
          ctx.fillStyle="red";
          ctx.fillText("Toca el bot√≥n o presiona ESPACIO", canvas.width/2, canvas.height/2 + 100);
        }
        return;
      }

      if (estado === "jugando"){
        // Jugador
        ctx.fillStyle=color;
        ctx.fillRect(x - JUGADOR_TAM/2, y - JUGADOR_TAM/2, JUGADOR_TAM, JUGADOR_TAM);

        // Enemigo
        ctx.fillStyle="white";
        ctx.fillRect(ex - etam/2, ey - etam/2, etam, etam);

        // Moneda amarilla
        ctx.fillStyle="gold";
        ctx.beginPath(); ctx.arc(mx,my,MONEDA_RADIO,0,Math.PI*2); ctx.fill();

        // Moneda roja
        ctx.fillStyle="red";
        ctx.beginPath(); ctx.arc(mrx,mry,MONEDA_RADIO,0,Math.PI*2); ctx.fill();

        // Rayo
        if (rayoActivo){
          ctx.font="26px Arial"; ctx.fillStyle="cyan";
          ctx.textAlign="center"; ctx.textBaseline="middle";
          ctx.fillText("‚ö°", rx, ry);
          ctx.textAlign="left"; ctx.textBaseline="alphabetic";
        }

        // Fresa (parpadea √∫ltimos 3s)
        if (fresaActiva){
          const restante = fresaExpira - Date.now();
          const blink = (restante <= 3000) && (Math.floor(Date.now()/300)%2===0);
          if (!blink){
            ctx.font="28px Arial"; ctx.fillStyle="pink";
            ctx.textAlign="center"; ctx.textBaseline="middle";
            ctx.fillText("üçì", fx, fy);
            ctx.textAlign="left"; ctx.textBaseline="alphabetic";
          }
        }

        // HUD
        ctx.fillStyle="white"; ctx.font="20px Arial"; ctx.textAlign="left";
        ctx.fillText("Puntos: " + puntosStage, 10, 25);
        ctx.fillText("Stage: " + stage, 10, 50);

        // Boost
        const ahora=Date.now();
        if (ahora < boostHasta){
          const restante = Math.ceil((boostHasta - ahora)/1000);
          ctx.fillStyle="yellow";
          ctx.fillText("‚ö° Velocidad (" + restante + "s)", 10, 75);
        }

        // Cartel STAGE
        if (mostrarStageCartel){
          ctx.fillStyle="white";
          ctx.font="48px Arial";
          ctx.textAlign="center"; ctx.textBaseline="middle";
          ctx.fillText("STAGE " + stage, canvas.width/2, canvas.height/2);
          if (Date.now() > stageCartelHasta) mostrarStageCartel=false;
        }

        // Textos flotantes
        textos.forEach(t => {
          ctx.save();
          ctx.globalAlpha = Math.max(0, t.alpha);
          ctx.fillStyle = "lime";
          ctx.font = "18px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "bottom";
          ctx.fillText(t.msg, t.x, t.y);
          ctx.restore();
        });
        return;
      }

      // GAME OVER
      if (estado === "gameover"){
        if (Math.floor(Date.now()/500)%2===0){
          ctx.fillStyle="red"; ctx.font="40px Arial";
          ctx.textAlign="center";
          ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);
        }
        ctx.fillStyle="yellow"; ctx.font="25px Arial";
        ctx.fillText("Puntos: " + puntosStage, canvas.width/2, canvas.height/2 + 40);
        ctx.fillStyle = "cyan";
        ctx.font = "22px Arial";
        ctx.fillText("Stage alcanzado: " + stage, canvas.width/2, canvas.height/2 + 70);

        if (Math.floor(Date.now()/500)%2===0){
          ctx.fillStyle="white"; ctx.font="20px Arial";
          ctx.fillText("Toca el bot√≥n o presiona R para reiniciar", canvas.width/2, canvas.height/2 + 110);
        }
      }
    }

    function loop(){
      actualizar();
      dibujar();
      requestAnimationFrame(loop);
    }

    // ======== Inicio ========
    function firstLayout() {
      resizeCanvas();
      checkOrientation();
      actualizarUIporEstado();
      btnStart.style.display = "block"; // mostrar bot√≥n en estado inicio
      centerStick(); // centrado (aunque est√© oculto)
    }
    firstLayout();
    loop();
  </script>
<script>
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("service-worker.js")
      .then(() => console.log("Service Worker registrado"))
      .catch(err => console.error("Error al registrar Service Worker", err));
  }
</script>
</body>
</html>
